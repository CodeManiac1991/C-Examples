#include <QCoreApplication>
#include "inhs.cpp"

/*

Типы наследования:

публичный  (public)     : public и protected данные наследуются без изменения доступа к ним;
защищенный (protected)  : все унаследованные данные становятся ТВОИМИ и потом стали защищенными;
приватный  (private)    : все унаследованные данные становятся ТВОИМИ и они потом стали приватными.

То есть если наследование пойдет дальше к " публичному внуку", там мы уже увидим настоящую разницу
между работой с классами потомками Inhetitor_protected и Inhetitor_private

*/

int main(int argc, char *argv[])
{
    Q_UNUSED(argc)
    Q_UNUSED(argv)

    cout<<"==================================================================================\n";

    Inhetitor_public* a = new Inhetitor_public();
    a->PUB_Method(); // в остальные методы не можем достучаться, так как доступ к протектед и приват родителя
    delete a;

    cout<<"==================================================================================\n";

    Inhetitor_protected* b = new Inhetitor_protected();
    //b->PUB_Method();
    //Error - PUB_Method стал protected, поэтому напрямую взять его нельзя, только внутри класса можно:
    b->getPublic();
    b->getProtected();
    delete b;

    cout<<"==================================================================================\n";

    Inhetitor_private* c = new Inhetitor_private();
    //c->PUB_Method();
    //Error - PUB_Method и PRT_Method стали private, поэтому напрямую взять его нельзя, только внутри класса можно(почемуто):
    c->getPublic();
    c->getProtected();
    delete c;

    cout<<"==================================================================================\n";

    GrandSon_protected* d = new GrandSon_protected();
    delete d;

    cout<<"==================================================================================\n";

    GrandSon_private* e = new GrandSon_private();
    delete e;

    cout<<"==================================================================================\n";

    Incest* f = new Incest();
    delete f;

    cout<<"==================================================================================\n";

    //Base *g = new Incest(); // так не получится сделать upcast
    //Base *g = new Inhetitor_protected(); // так тоже,потому что протектед
    Base *g = new Inhetitor_public(); // а так можно  потому что паблик
    delete g;

    // Есть еще такое понятие как даункаст, это инверсия инициализации памяти, но работает она только в частных случаях
    cout<<"==================================================================================\n";

    return 0;
}
